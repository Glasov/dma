# Графы: DFS и BFS

Вспомним для начала, что такое граф.

Граф задаётся двумя множествами: множеством вершин V и множеством упорядоченных пар вершин, называемых рёбрамы E.

<img width="365" alt="image" src="https://github.com/user-attachments/assets/6db2c783-cf5f-4bc1-af07-59e1b4487271" />

Это хорошо, но это больше касается математики. Что касается алгоритмов, как правило вершины - это просто целочисленные значения, чаще всего просто индексы.

Ну а рёбра - просто пары чисел.

Есть несколько способов хранения графов, но мы будем рассматривать самые распространённые способы, а именно:

1. Матрица смежности
2. Списки смежности

Каждый из них используется в разных случаях, и каждый имеет сильные и слабые стороны:

<img width="970" alt="image" src="https://github.com/user-attachments/assets/afb202eb-713c-467e-b567-044a57bba521" />

Для наглядности посмотрим на хранение одинаковых графов в разных форматах (слева - матрица смежности, справа - списки смежности):

<img width="699" alt="image" src="https://github.com/user-attachments/assets/ea1d880f-9394-4ded-a4a4-1bf8ec0e7982" />

## DFS

DFS (Depth-first search) - алгоритм, который решает задачу обхода всех вершин заданного графа.

Предположим, что нам надо обойти все вершины графа G.

Выберем начальную вершину и будем идти по рёбрам в вершины, в которых ещё не были.

Если не можем пройти по какому-либо из рёбер, поднимемся в прошлую вершину (если есть), и попробуем пройти по его рёбрам.

Получается, что мы проходим максимум вглубь графа, потом поднимаемся на единицу вверх, то есть в родитель, и опять пытаемся пойти вглубь - отсюда и название.

Псевдокод выглядит следующим образом:

```
function DFS(v, visited, graph):
    visited.add(v)
    for neighbor in graph.get_neighbors(v):
        if neighbor not in visited:
            DFS(neighbor, visited)
```

DFS используется в основе разных других аглоритмов, помогает решать, например, следующие задачи:

<img width="1026" alt="image" src="https://github.com/user-attachments/assets/1063dcd2-54fa-4eb4-92bf-17d635739f6f" />

## BFS

BFS (Breadth-first search) - тоже решает задачу обхода графа, но немного по-другому:

Выберем начальную вершину и будем идти по рёбрам в вершины, в которых ещё не были.

Но в отличие от DFS идём по "слоям" графа:

Сначала посетим соседей. Потом - соседей соседей, потом - соседей соседей соседей и так далее. Получается, мы проходим по "слоям" графа:

<img width="408" alt="image" src="https://github.com/user-attachments/assets/b6631d54-4a87-4490-9d92-c329ce98678e" />

Псевдокод:

```
function BFS(start, visited, graph):
    queue = deque([start])
    while queue not empty:
        v = queue.popleft()
        for neighbor in graph.get_neighbors(v):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

И задачи, которые помогает решить этот алгоритм:

<img width="1074" alt="image" src="https://github.com/user-attachments/assets/a295e69b-6906-4ea2-82b4-be2ff92bfacc" />
