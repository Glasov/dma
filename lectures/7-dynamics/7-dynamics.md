# Лекция 7: Динамическое программирование (ДП)

## О чём будем говорить

- Введение в идею ДП  
- Сравнение с жадными алгоритмами  
- Подходы: top-down и bottom-up  
- Задачи на один параметр  
- Практика: лестница, стоимость шага, «без 3 единиц подряд»

## Что такое динамическое программирование?

Динамическое программирование — это метод решения задач, сводящихся к оптимизации или перебору с запоминанием результатов подзадач.

Основные признаки задачи, решаемой ДП:

- **Оптимальная подструктура** — задачу можно разбить на более простые
- **Пересечение подзадач** — одни и те же подзадачи возникают многократно

> Динамика — это 99% практика и 1% теория. Каждая задача — уникальна.  
> Рекуррентное соотношение нужно вывести, его нельзя угадать заранее.

## Сравнение с жадными алгоритмами

| Характеристика       | Жадные алгоритмы          | Динамическое программирование |
|----------------------|---------------------------|--------------------------------|
| Опора на прошлые шаги| Нет                       | Да                             |
| Гарантия оптимальности| Только при выполнении условий | Всегда при корректной модели |
| Универсальность      | Ограничена                | Очень широкая                 |

## Классический пример: Числа Фибоначчи

Рекуррентное определение:

```python3
F(n) = F(n - 1) + F(n - 2)  
F(0) = 1, F(1) = 1
```

## Наивная реализация

```python
def F(n):  
  if n < 0:  
    raise Exception("no-no")  
  if n == 0 or n == 1:  
    return 1  
  return F(n - 1) + F(n - 2)
```

## Иллюстрация: дерево вызовов

<img width="223" alt="image" src="https://github.com/user-attachments/assets/9162f5b5-db2a-48c6-84d3-0b0ac16b50c6" />

Здесь видно множество повторных вызовов — например, `F(2)` вычисляется несколько раз.

(и это ещё не всё дерево!!)

## Мемоизация (top-down)

```python
def F(n, dp):  
  if dp[n] == None:  
    dp[n] = F(n - 1, dp) + F(n - 2, dp)  
  return dp[n]

dp = [None] * (n + 1)  
dp[0] = dp[1] = 1
```

После такой оптимизации у нас получится уменьшить дерево вызовов, то есть работы надо будет выполнять меньше

<img width="155" alt="image" src="https://github.com/user-attachments/assets/6d37d52a-024c-4a0b-b470-bc02231b2044" />

## Bottom-up: итеративное ДП

```python
dp = [0] * (n + 1)  
dp[0] = dp[1] = 1  
for i in range(2, n + 1):  
  dp[i] = dp[i - 1] + dp[i - 2]
```

## Что такое динамика?

- Разбиение задачи на подзадачи  
- Пересечение подзадач  
- Использование уже посчитанных решений  

<img width="321" alt="image" src="https://github.com/user-attachments/assets/ff6fa89a-6955-4a62-a587-31db9713d78f" />

## Индукция и ДП

Можно провести параллель с математической индукцией. В динамике тоже есть базовый случай, и тоде есть "переход" - рекуррентное соотношение:

**База:**
```python
dp[0] = 1  
dp[1] = 1
```

**Переход:**  
`dp[n] = dp[n - 1] + dp[n - 2]`

## Общий алгоритм ДП

- Разбить задачу на подзадачи  
- Выразить очередную через предыдущие (рекуррентное соотношение)  
- Задать начальные значения  
- Определить порядок вычислений  
- Указать, где находится итоговый ответ (тут не всегда очевидно, иногда он может находиться не в конце массива dp, а где-то посередине)

## Практика: Кол-во способов дойти до `n`-й ступеньки

Дана лестница из n ступенек. Мы можем перейти на следующую, послеследующую и после-послеследующую ступенькю из текущей.

Наша задача - определить количество способов попасть на ступеньку n с пола (сутпеньки 0)

Предположим, что dp[i] - количество способов попасть на ступеньку i с пола.

Тогда можем задать рекуррентное соотношение: `dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]`

Наш базовый случай будет:

```python
dp[0] = 1
dp[1] = 1
dp[2] = 2
```

## Расширенная версия: стоимость ступенек

Есть массив `cost`, где `cost[i]` — цена наступить на ступеньку `i`.  
Найти минимальную суммарную стоимость пути на `n`-ю ступеньку.

В этом случае наше рекуррентное соотношение изменится:

`dp[i] = cost[i] + min(dp[i - 1], dp[i - 2], dp[i - 3])`

```python
dp[0] = 0
dp[1] = cost[0]
dp[2] = cost[1]
for i in range(3, n + 1):  
  dp[i] = cost[i] + min(dp[i - 1], dp[i - 2], dp[i - 3])
```

## Задача "без трёх единиц подряд"

Мы строим последовательности из нулей и единиц, где не может быть трёх единиц подряд. Наша задача - сказать, сколько таких последовательностей будет с длинной n.

Чтобы решить эту задачу, полезно будет выписать первые несколько n:

```python
dp[0] = 1
dp[1] = 2 (0, 1)
dp[2] = 4 (00, 01, 10, 11)
dp[3] = 7 (000, 001, 010, 100, 011, 101, 110)
dp[4] = 13 (0000, 0001, 0010, 0100, 1000, 0011, 0101, 1001, 0110, 1010, 1100, 1011, 1101)
```

Давайте посмотрим на...

последовательности, которые заканчиваются на 0: 0000, 0010, 0100, 1000, 0110, 1010, 1100 - 7, столько же, сколько в dp[3]

на 01: 0001, 0101, 1001, 1101 - 4, сколько же было в dp[2]

на 011: 0011, 1011 - 2, сколько в dp[1]

Дело в том, что мы можем всем последовательносям длиной 3 добавить 0 в конце, длиной 2 - 01, а длиной 1 - 011, и мы получим корректные последовательности длиной 4.

Тогда наше рекуррентное соотношение будет следующим:

dp[n] = dp[n - 1] + dp[n - 2] + dp[n - 3]
