# Лекция 6: Жадные алгоритмы

## Цель занятия

- Разобраться в принципах жадного подхода
- Понять, когда он работает, а когда — нет
- Научиться формулировать жадные критерии и доказывать корректность решений

## Что такое жадный алгоритм?

Жадный алгоритм — это стратегия, при которой на каждом шаге выбирается **наилучший локальный вариант** с точки зрения текущего состояния. Ожидается, что такая последовательность решений приведёт к **глобальному оптимуму**.

> Основная идея: **"локальный выбор — ключ к глобальному успеху"**

Важно понимать: жадный подход не всегда даёт оптимальный результат. Он работает корректно только при выполнении определённых условий.

## Когда работает жадный алгоритм?

Чтобы жадный подход был корректным, должны быть выполнены два свойства задачи:

1. **Свойство жадного выбора** — часть оптимального решения можно получить, выбрав наилучший доступный вариант на текущем шаге.

2. **Оптимальная подструктура** — оптимальное решение задачи содержит оптимальные решения её подзадач.

Если хотя бы одно из этих условий не выполняется — жадный алгоритм может привести к неверному результату.


## Классические примеры

- Размен монет
- Алгоритм Дейкстры
- Кодирование Хаффмана
- Задача об интервалах
- (Опционально: рюкзак с дробями — работает, рюкзак 0/1 — нет)

## Пример 1: Минимальное количество монет

**Задача:** даны номиналы монет и сумма `N`. Требуется выдать сумму **наименьшим числом монет**.

Жадный алгоритм: на каждом шаге берём **максимально возможную монету**, не превышающую остаток.

```python
def greedy_coins(coins, target):
    coins.sort(reverse=True)
    result = []
    for coin in coins:
        while target >= coin:
            target -= coin
            result.append(coin)
    return result
```

**Пример:**

Номиналы: 1, 2, 5, 10  
Сумма: 27  
Жадный выбор: 10 + 10 + 5 + 2 → 4 монеты

**Контрпример:**

Номиналы: 1, 3, 4  
Сумма: 6  
Жадный: 4 + 1 + 1 → 3 монеты  
Оптимум: 3 + 3 → 2 монеты

**Вывод:** при произвольных номиналах жадный алгоритм может давать неоптимальное решение.

## Пример 2: Кодирование Хаффмана

**Задача:** Построить префиксный код с минимальной суммарной длиной кодов.  
Жадность проявляется в объединении двух **наименее частых** символов.

### Шаги алгоритма:

1. Подсчитать частоты символов
2. Построить дерево:
   - Повторять:
     - выбрать два узла с наименьшими частотами
     - объединить в один новый узел
3. Присвоить код:
   - 0 — левый потомок
   - 1 — правый потомок

```python
import heapq
from collections import Counter

def huffman_code(symbols):
    heap = [[freq, [char, ""]] for char, freq in symbols.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        lo = heapq.heappop(heap)
        hi = heapq.heappop(heap)
        for pair in lo[1:]: pair[1] = "0" + pair[1]
        for pair in hi[1:]: pair[1] = "1" + pair[1]
        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])
    return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[1]), p))
```

**Примечание:** Жадность в Хаффмане проявляется в стратегии объединения — всегда выбираем наименее частые.

## Пример 3: Задача о рюкзаке

**Вариант 1: Дробный рюкзак**  
Можно брать доли предметов → работает жадный подход: сортируем по value/weight, берём максимально возможное.

**Вариант 2: 0/1 рюкзак**  
Брать предмет целиком или не брать. Жадный подход **не даёт гарантии оптимальности**.

**Пример:**

| Вес  | Стоимость |
|------|-----------|
| 20кг | 100$      |
| 30кг | 120$      |
| 10кг | 60$       |

Ограничение по весу: 50кг

Жадный подход (по value/weight):  
30 (4$/кг) + 10 (6$/кг) → 180$

Оптимум:  
20 (5$/кг) + 30 (4$/кг) → 220$

**Вывод:** жадность не работает в задаче 0/1 рюкзака.


## Пример 4: Задача о непересекающихся интервалах

**Задача:** Даны интервалы (si, fi). Требуется выбрать максимальное по количеству множество непересекающихся интервалов.

Жадная стратегия:  
**Сортируем по времени окончания** (fi), и на каждом шаге выбираем первый подходящий интервал.

**Почему работает?**  
Можно доказать, что если в оптимальном решении первый интервал заканчивается позже, чем наш, то мы можем заменить его без потери оптимальности.

```python
def max_non_overlapping(intervals):
    intervals.sort(key=lambda x: x[1])
    result = []
    last_end = -float('inf')
    for start, end in intervals:
        if start >= last_end:
            result.append((start, end))
            last_end = end
    return result
```

## Как строить жадный алгоритм

1. Сформулировать **жадный критерий** — что брать на каждом шаге?
2. Проверить:
   - Свойство жадного выбора
   - Оптимальную подструктуру
3. Реализовать:
   - Отсортировать данные (часто по весу, стоимости, времени и т.д.)
   - Пройтись по элементам и накапливать решение

## Как доказывать корректность

### Метод замены

Показываем, что любое оптимальное решение можно заменить на жадное **без ухудшения результата**.

Пример: в задаче об интервалах — если первое выбранное жадное решение отличается от первого интервала в оптимальном, мы можем его подменить.

### Математическая индукция

Предполагаем, что первые `k` шагов работают корректно, и доказываем корректность `k+1`-го.

## Преимущества жадных алгоритмов

- Простота реализации
- Быстрое выполнение (часто O(n log n))
- Эффективность на практике

## Недостатки жадных алгоритмов

- Не всегда дают оптимальное решение
- Требуют строгого анализа применимости
- Не работают при наличии глобальных зависимостей
